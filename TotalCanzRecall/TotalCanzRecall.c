#pragma config(UserModel, "H:/Users/Jim/Documents/git/lego-mindstorms-nxt/TotalCanzRecall/TotalCanzRecallModel.h")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// TotalCanzRecall.c
/*
	Copyright (c) [2019] [James C DiNunzio, II]

	This file is part of TotalCanzRecall.
	TotalCanzRecall is free software: you can redistribute it and/or modify
  it under the terms of the Lesser GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  TotalCanzRecall is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with TotalCanzRecall.  If not, see <https://www.gnu.org/licenses/>.
*/

// TotalCanzRecall.c
// Mindstorm NXT program to collect cans in "room" surrounded by black tape and
// push them back to the recycle area of 8" x 11" at the starting corner.

#pragma DebuggerWindows("debugStream")
#pragma DebuggerWindows("nxtLCDScreen")

#include "vector.c"
#include "constants.c"
#include "trig.c"
#include "wheelTicks.c"
#include "pose.c"
#include "globals.c"
#include "localize.c"
#include "navigation.c"
#include "movementCommands.c"
#include "target.c"
#include "sound.c"

#define max(n,m) ((n) > (m) ? (n) : (m))

// Task to stop robot if black line is detected - used when returning a can to the recycle area
task stopAfterBlackLine()
{
	while (1)
	{
		if (SensorValue[Light] < LightSensor_FloorTile_BlackTape_Threshhold)
		{
			while (1)
			{
				if (SensorValue[Light] > LightSensor_FloorTile_BlackTape_Threshhold)
				{
					writeDebugStreamLine("Black line passed.");
					// stop robot
					motor[Master] = 0;
					return;
				}
				wait1Msec(50);
			}
		}
		wait1Msec(50);
	}
}

// Task to turn robot toward center of room if black line hit - used to detect going out of bounds
task turnTowardCenterIfBlackLineHit()
{
	while (1)
	{
		if (SensorValue[Light] < LightSensor_FloorTile_BlackTape_Threshhold)
		{
			gTurnTowardCenterIfBlackLineHitActing = true;
			writeDebugStreamLine("Black line detected.");
			// stop robot currently going straight
			motor[Master] = 0;
			wait1Msec(50);
			turnTorwardCenterOfRoom();
			wait1Msec(50);
			driveRobotStraightInMm(200);
			wait1Msec(50);
			gTurnTowardCenterIfBlackLineHitActing = false;
			return;
		}
		wait1Msec(50);
	}
}

// Can collecting main task
task main()
{
	int canCount = 0;
	clearDebugStream();
	nVolume = SoundVolume;
  bFloatDuringInactiveMotorPWM = false;
  nPidUpdateInterval    = 10;   // Best performance if we do really frequent updates
                                // (i.e. calculation) on the motor speeds to correct for errors.

	// start robot in center of the recycle area facing down the edge of the "room" toward the far side
	setPose(gCurrentPose, home[0], home[1], 0.0);

	// play "time to collect the cans"
	playSoundFile("TimeToCo.rso");
	waitUntil(bSoundActive == false);

	// start the localization task
	startTask(localize);

	bool nearOrAtHome = true;
	float distToClosestTarget, angleToClosestTarget;

	driveRobotStraightInMm(250); // get out of white recycle area
	while (1)
	{
		// If at home turn robot to face center of "room"
		if (nearOrAtHome)
		{
		  turnTorwardCenterOfRoom();
		}
		wait1Msec(50);
		nearOrAtHome = false;
		//  find closest can, capture it, and return it to recycle area.
		if (findClosestTarget(distToClosestTarget, angleToClosestTarget))
		{
			wait1Msec(50);
			// if can is close enough, execute capture
			if (distToClosestTarget < DistCloseEnoughForNoCorrection)
			{
				writeDebugStreamLine("distance to target is %d, attempting to capture it", distToClosestTarget);
				bool captured = captureTarget(distToClosestTarget + captureSlopDistance, angleToClosestTarget);
				if (captured)
				{
					writeDebugStreamLine("Object captured!");
					wait1Msec(50);
					// detect color of object and play sound
					// rotate so object is in front of color sensor
					rotateRobotInDeg(AngleToRotateToSenseCanColor, fineRotatePower);
					playColorSound();
					waitUntil(bSoundActive == false);
					writeDebugStreamLine("Bringing object home");
					// start task to detect when black line (around recycle area) is crossed
					startTask(stopAfterBlackLine);
					goToDestination(home);
					stopTask(stopAfterBlackLine);
					wait1Msec(50);
					driveRobotStraightInMm(BackupDistanceAfterDropOff);
					rotateRobotInDeg(-180);
					nearOrAtHome = true;
					canCount++;
				}
				else // not captured
				{
					writeDebugStreamLine("Object missed!");
					playSoundFile("Woops.rso");
					// backup a little and try again
					driveRobotStraightInMm(-200);
				}
			}
			else // distToClosestTarget >= DistCloseEnoughForNoCorrection - not close enough, drive half way to it.
			{
				writeDebugStreamLine("distance to target is %d > threshold, driving to it and scanning again.", distToClosestTarget);
				rotateRobotToHeadingInDeg(angleToClosestTarget, rotatePower);
				// TBD think about whether to just go DistCloseEnoughForNoCorrection here before another sweep
				// Start task to turn around if we hit the black line boundary of the "room"
				startTask(turnTowardCenterIfBlackLineHit);
				driveRobotStraightInMm(distToClosestTarget / 2.0);
			  waitUntil(gTurnTowardCenterIfBlackLineHitActing == false);
				stopTask(turnTowardCenterIfBlackLineHit);
			}
		}
		else // found no target so go forward some toward center of room
		{
			writeDebugStreamLine("Found no target so going toward center of room");
			turnTorwardCenterOfRoom();
			driveRobotStraightInMm(DistCloseEnoughForNoCorrection);
		}

		// Check if we are done collecting the specified number of cans.
		if (canCount == NumberOfCansToCollect)
		{
	   	playSoundFile("AllDone.rso");
			waitUntil(bSoundActive == false);
			stopAllTasks();
			return;
		}
  	wait1Msec(50);
	}
}
