#pragma config(UserModel, "h:/Users/jim/Documents/git/lego-mindstorms-nxt/TotalCanzRecall/TotalCanzRecallModel.h")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int LightSensor_WhitePaper = 60;
const int LightSensor_FloorTile = 40;
const int LightSensor_BlackTape = 30;
const int LightSensor_FloorTile_BlackTape_Threshhold = (LightSensor_FloorTile + LightSensor_BlackTape) / 2;
const int LightSensor_BlackTape_WhitePaper_Threshhold = (LightSensor_BlackTape + LightSensor_WhitePaper) / 2;

// robot dimensions in mm
const float robotWheelRadius = 27.45; // 56mm diameter printed on the tire!
const float robotWheelBaseLength = 120.00;
const int robotWheelTicksPerRevolution = 360;

// calibration constants
const float wheelSizeError = 0.0;
const float ticksPerMm = robotWheelTicksPerRevolution/(2*PI*robotWheelRadius);
const float leftTicksPerMm = ticksPerMm;
const float rightTicksPerMm = ticksPerMm - wheelSizeError;

// Motor control
const int maxPower = 50;
const int rotatePower = 25;
const int fineRotatePower = 15;
const TSynchedMotors synchLeftRight = synchBC;
const TSynchedMotors synchRightLeft = synchCB;
const TSynchedMotors synchMode = synchRightLeft;
const int Master = Right;

// Search constants
const int captureSlopDistance = 25;
const int NumberOfCansToCollect = 3;
const int halfSweepAngle = 75;
const int BackupDistanceAfterDropOff = -200;
const int DistCloseEnoughForNoCorrection = 600;
const int HeadingToPointBeforeSearch = 45;
const int MaxCaptureDistance = 12;

// other constants
const float epsilon = 0.000006;
const int SoundVolume = 4;
const int AngleToRotateToSenseCanColor = 18;

typedef float Vector2d[2];
// globals
Vector2d home = {139.7, 107.95};
Vector2d roomCenter = {914.4, 914.4};

bool gStopGoingToDest;
TSemaphore currentPose;

struct WheelsVector
{
	float left;
	float right;
};

struct WheelsTicks
{
	int left;
	int right;
};

struct Pose
{
	Vector2d pos;
	float theta;
};

Pose gCurrentPose;

#define max(n,m) ((n) > (m) ? (n) : (m))

void assignVector2d(Vector2d& lvalue, Vector2d rvalue)
{
	lvalue[0] = rvalue[0];
	lvalue[1] = rvalue[1];
}

void assignPose(Pose& lvalue, Pose rvalue)
{
	lvalue.pos[0] = rvalue.pos[0];
	lvalue.pos[1] = rvalue.pos[1];
	lvalue.theta = rvalue.theta;
}

void setPose(Pose& pose, float x, float y, float theta)
{
	pose.pos[0] = x;
	pose.pos[1] = y;
	pose.theta = theta;
}

float myRadiansToDegrees(float radians);
float myDegreesToRadians(float degrees);

// Trigonometry routines
//float normalizeAngle(float angleInRadians)
//{
//	float angle = myRadiansToDegrees(angleInRadians);

//	// reduce the angle
//	float normAngle =  angle % 360;

//	// force it to be the positive remainder, so that 0 <= angle < 360
//	normAngle = (angle + 360) % 360;

//	// force into the minimum absolute value, so that -180 < angle <= 180
//	if (normAngle > 180)
//	{
//	    normAngle -= 360;
//	}
//	return myDegreesToRadians(normAngle);
//}

float normalizeAngle(float theta)
{
	return atan2(sin(theta), cos(theta));
}

// Odometry routines

// v is the intended velocity of the robot (m/s)
// angle is the angle to turn (rads/s)
// return value is the left and right wheel velocities in rads/s
void velocityToDiff(int v, float theta, WheelsVector& diffV)
{
	diffV.left =  ((2.0 * v) - (theta * robotWheelBaseLength)) / (2.0 * robotWheelRadius);
 	diffV.right = ((2.0 * v) + (theta * robotWheelBaseLength)) / (2.0 * robotWheelRadius);
}

void updateOdometry(WheelsTicks& prevTicks, Pose prevPose, Pose& newPose)
{
	// compute difference in ticks since prevTicks
	int ticksRight = nMotorEncoder[Right];
	int ticksLeft = nMotorEncoder[Left];

	int dTicksRight = ticksRight - prevTicks.right;
	int dTicksLeft = ticksLeft - prevTicks.left;

	// estimate the wheel movements
	float dRightWheel = dTicksRight / rightTicksPerMm;
	float dLeftWheel =  dTicksLeft / leftTicksPerMm;
	float dCenter = 0.5 * (dRightWheel + dLeftWheel);

	// calculate the new pose
	newPose.pos[0] = prevPose.pos[0] + (dCenter * cos(prevPose.theta));
	newPose.pos[1] = prevPose.pos[1] + (dCenter * sin(prevPose.theta));
	newPose.theta = prevPose.theta + ((dRightWheel - dLeftWheel) / robotWheelBaseLength);

	// update the previous ticks
	prevTicks.right = ticksRight;
	prevTicks.left = ticksLeft;
}

// this is the slower and more accurate method
void updateOdometry2(WheelsTicks& prevTicks, Pose prevPose, Pose& newPose)
{
	// compute difference in ticks since last iteration
	int ticksRight = nMotorEncoder[Right];
	int ticksLeft = nMotorEncoder[Left];

	int dTicksRight = ticksRight - prevTicks.right;
	int dTicksLeft = ticksLeft - prevTicks.left;

	// estimate the wheel movements
	float dRightWheel = (2 * PI * robotWheelRadius * dTicksRight) / robotWheelTicksPerRevolution;
	float dLeftWheel = (2 * PI * robotWheelRadius * dTicksLeft) / robotWheelTicksPerRevolution;

	// handle case if going straight
	if (fabs(dLeftWheel - dRightWheel) < epsilon)
	{
		newPose.pos[0] = prevPose.pos[0] + dLeftWheel * cos(prevPose.theta);
		newPose.pos[1] = prevPose.pos[1] + dRightWheel * sin(prevPose.theta);
		newPose.theta = prevPose.theta;
	}
	else
	{
		// calculate the new pose not going straight
		float R = (robotWheelBaseLength * (dLeftWheel + dRightWheel)) / (2 * (dRightWheel - dLeftWheel));
		float wd = (dRightWheel - dLeftWheel) / robotWheelBaseLength;
		newPose.pos[0] = prevPose.pos[0] + R * sin(wd + prevPose.theta) - R * sin(prevPose.theta);
		newPose.pos[1] = prevPose.pos[1] - R * cos(wd + prevPose.theta) + R * cos(prevPose.theta);
		newPose.theta = normalizeAngle(prevPose.theta + wd);
	}

	// update the previous ticks
	prevTicks.right = ticksRight;
	prevTicks.left = ticksLeft;
}


// Vector math routines

void addVector2d(Vector2d a, Vector2d b, Vector2d& sum)
{
	sum[0] = a[0] + b[0];
	sum[1] = a[1] + b[1];
}

float dotProduct(Vector2d a, Vector2d b)
{
	return a[0] * b[0] + a[1] * b[1];
}

// get the result of rotating a vector by theta radians
void rotateVector2d(Vector2d v, float theta, Vector2d& newV)
{
	float sinTheta = sin(theta);
  float cosTheta = cos(theta);

  newV[0] = v[0]*cosTheta - v[1]*sinTheta;
  newV[1] = v[0]*sinTheta + v[1]*cosTheta;
}

void rotateAndTransVector2d(Vector2d v, float theta, Vector2d vTrans, Vector2d& newV)
{
	rotateVector2d(v, theta, newV);
	Vector2d final;
	addVector2d(newV, vTrans, final);
	assignVector2d(newV, final);
}

float magnitude(Vector2d v)
{
	return sqrt(v[0] * v[0] + v[1] * v[1]);
}

// Pose routines
void invertPose(Pose inPose, Pose& invertedPose)
{
	invertedPose.theta = -inPose.theta;
	inPose.pos[0] = -inPose.pos[0];
	inPose.pos[1] = -inPose.pos[1];
	rotateVector2d(inPose.pos, invertedPose.theta, invertedPose.pos);
}

// calculate heading vector to destination from robot's POV
void calculateVectorToDest(Pose pose, Vector2d dest, Vector2d& toDest)
{
	// get the inverse of the robot's pose
	Pose invertedPose;
	invertPose(pose, invertedPose);

	// calculate the vector to the destination from the robot's POV
	rotateAndTransVector2d(dest, invertedPose.theta, invertedPose.pos, toDest);
}


// Navigation routines

int distanceToTicks(float distance)
{
	return round(distance * ticksPerMm);
}

// calculate and return the angle in radians to turn the robot to face the destination
// input: toDest - vector in robot's POV to destination
float calculateTurnAngleToDest(Vector2d toDest)
{
	return atan2(toDest[1], toDest[0]);
}

// calculate number of wheel ticks to go to reach destination
int calculateTicksToDest(Pose pose, Vector2d toDest)
{
	return distanceToTicks(magnitude(toDest));
}


// Robot moving commands

// Rotate the robot around the center between its drive wheels
// power right wheel and left wheel in opposite directions
void rotateRobot(float angle, int power = rotatePower)
{
	if (fabs(angle) < epsilon)
	{
		return;
	}
	// compute number of ticks
	float distanceToGo = angle * robotWheelBaseLength / 2.0;
	int ticksToGo = round(distanceToGo * ticksPerMm);
	if (ticksToGo < 0)
	{
		ticksToGo = -ticksToGo;
		power = -power;
	}

	if (ticksToGo == 0)
	{
		return;
	}

	nSyncedMotors = synchMode; // sync motors Right as master and Left as slave
//	nMotorEncoder[Right] = 0; // clear motor encoder value
	nSyncedTurnRatio = -100; // motors move in opposite direction of each other
	nMotorEncoderTarget[Master] = ticksToGo;
	motor[Master] = power;

	while (nMotorRunState[Master] != runStateIdle) //while Right motor is not in idle
	{
		// do nothing until the motor encoder target has been reached
	}
	motor[Master] = 0;
	nSyncedMotors = synchNone;
}

float myRadiansToDegrees(float radians)
{
	return (180 * radians) / PI;
}


float myDegreesToRadians(float degrees)
{
	return (PI * degrees) / 180.0;
}

void rotateRobotInDeg(float degrees, int power = rotatePower)
{
	rotateRobot(myDegreesToRadians(degrees), power);
}

void rotateRobotToHeadingInDeg(float newHeading, int power = rotatePower)
{
	float result = (newHeading - myRadiansToDegrees(gCurrentPose.theta)) % 360;
	if (result >= 180.0)
	{
		result -= 360.0;
	}
//	writeDebugStreamLine("current heading = %d, new heading = %d, turning %d",
//		myRadiansToDegrees(gCurrentPose.theta),newHeading, result);
	rotateRobotInDeg(result, power);
}

void driveRobotStraight(int ticks)
{
	// Drive robot in straight line to destination
//	nSyncedMotors = synchMode; // sync motors Left as master and Right as slave
//	nSyncedTurnRatio = 100; // motors move at 100% alignment to each other
//	nMotorEncoder[Right] = 0;
	if (ticks == 0)
	{
		return;
	}

	int power = maxPower;
	if (ticks < 0)
	{
		ticks = -ticks;
		power = -power;
	}

	// vector in robot POV to target
	Pose startPose;
	semaphoreLock(currentPose);
	assignPose(startPose, gCurrentPose);
	semaphoreUnlock(currentPose);
	Vector2d Vt = { cos(startPose.theta), sin(startPose.theta) };

	nMotorEncoderTarget[Right] = ticks;	nMotorEncoderTarget[Left] = ticks;
	motor[Right] = power;	motor[Left] = power;

	while (nMotorRunState[Right] != runStateIdle || nMotorRunState[Left] != runStateIdle) //while Right and Left motors are not in idle
	{
	//	Pose pose;
	//	// keep robot driving straight by checking if current location is veering right or left and
	//	// adjusting the syncedTurnRatio to compensate all until the motor encoder target has been reached
	//	semaphoreLock(currentPose);
	//	assignPose(pose, gCurrentPose);
	//	semaphoreUnlock(currentPose);
	//	Vector2d Vc = { pose.pos[0] - startPose.pos[0], pose.pos[1] - startPose.pos[1] };
	//	float dot = Vt[0] * - Vc[1] + Vt[1] * Vc[0];
	//	if (dot > 0)
	//	{
	//		writeDebugStreamLine("veering left");
	//	}
	//	else if (dot < 0)
	//	{
	//		writeDebugStreamLine("veering right");
	//	}
	//	else
	//	{
	//		writeDebugStreamLine("going straight!");
	//	}
	//	wait1Msec(500);
	}
	motor[Right] = 0;
	motor[Left] = 0;
//	nSyncedMotors = synchNone;
}

void driveRobotStraightInMm(float distance)
{
	driveRobotStraight(distanceToTicks(distance));
}

//const int DistCloseEnoughForNoCorrectionInTicks = distanceToTicks(DistCloseEnoughForNoCorrection);

void goToDestination(Vector2d dest)
{
	Pose pose;
	Vector2d toDest;
	int ticksToDest;
	bool doCorrection = false;

	do
	{
		semaphoreLock(currentPose);
		assignPose(pose, gCurrentPose);
		semaphoreUnlock(currentPose);
		// calculate vector to destination in robots POV
		calculateVectorToDest(pose, dest, toDest);
		float angleToTurn = calculateTurnAngleToDest(toDest);
		ticksToDest = calculateTicksToDest(pose, toDest);

		//if (ticksToDest > DistCloseEnoughForNoCorrectionInTicks)
		//{
		//	// go a short distance and recalculate vector on next iteration
		//	ticksToDest = DistCloseEnoughForNoCorrectionInTicks;
		//	doCorrection = true;
		//}
		//else
		//{
		//	doCorrection = false;
		//}

		// Turn robot to face destination
		rotateRobot(angleToTurn);

		wait1Msec(50);
		// Drive robot straight toward destination
		driveRobotStraight(ticksToDest);
		wait1Msec(50);
	}
	while(doCorrection && !gStopGoingToDest);
}

void goToDestination(float x, float y)
{
	Vector2d dest = {x, y};
	goToDestination(dest);
}

void assignWheelsTicks(WheelsTicks& ticks, int right, int left)
{
	ticks.left = left;
	ticks.right = right;
}

void assignWheelsTicks(WheelsTicks& lvalue, WheelsTicks rvalue)
{
	lvalue.right = rvalue.right;
	lvalue.left = rvalue.left;
}

// must call this periodically to avoid "wrap around" of values ~90 revolutions)
void resetMotorEncoders()
{
	nMotorEncoder[Right] = 0;
	nMotorEncoder[Left] = 0;
}

task localize()
{
	semaphoreInitialize(currentPose);
	const int maxSafeTicks = 45 * 360;
	Pose newPose;
	WheelsTicks currentTicks;
	assignWheelsTicks(currentTicks, 0, 0);

	while (1) // run forever
	{
		updateOdometry(currentTicks, gCurrentPose, newPose);
		newPose.theta = normalizeAngle(newPose.theta);
		semaphoreLock(currentPose);
		assignPose(gCurrentPose, newPose);
		semaphoreUnlock(currentPose);
		if (nSyncedMotors == synchNone && (currentTicks.left > maxSafeTicks || currentTicks.right > maxSafeTicks))
		{
			resetMotorEncoders();
			assignWheelsTicks(currentTicks, 0, 0);
		}
		displayCenteredBigTextLine(1, "x=%d", round(gCurrentPose.pos[0]));
		displayCenteredBigTextLine(3, "y=%d", round(gCurrentPose.pos[1]));
		displayCenteredBigTextLine(5, "a=%d", round(myRadiansToDegrees(gCurrentPose.theta)));
		wait1Msec(50);
	}
}


task main();

TSemaphore findObjectResultSemaphore;
TSemaphore sweepingForObjectSemaphore;
float gTargetAngle = 0.0;
float gTargetDistance = 0.0;

task findClosestTargetDuringScan()
{
  semaphoreInitialize(findObjectResultSemaphore);
	float closestTargetDistance;
	float closestTargetAngle;

	while (1)
	{
		closestTargetDistance = 1000;
		closestTargetAngle = 0;
 	  //writeDebugStreamLine("Monitor: locking result semaphore");
		semaphoreLock(findObjectResultSemaphore);
		//writeDebugStreamLine("Monitor: waiting until sweep starts");
		while (getSemaphoreTaskOwner(sweepingForObjectSemaphore) != main)
		{
			//wait until sweep starts
		}
		//writeDebugStreamLine("Monitor: sweep started");
		while (!bDoesTaskOwnSemaphore(sweepingForObjectSemaphore))
		{
//			displayCenteredBigTextLine(2, "Object Distance");
//			displayCenteredBigTextLine(4, "%d", SensorValue[Distance]);

			if (SensorValue[Distance] < closestTargetDistance)
			{
				closestTargetDistance = SensorValue[Distance];
				closestTargetAngle = gCurrentPose.theta;
			}
			semaphoreLock(sweepingForObjectSemaphore, 50);
		}
		//writeDebugStreamLine("Monitor: sweep finished setting result");
		gTargetDistance = closestTargetDistance;
		gTargetAngle = closestTargetAngle;
		semaphoreUnlock(sweepingForObjectSemaphore);
		semaphoreUnlock(findObjectResultSemaphore);
	}
}

bool findClosestTarget(float& distance, float& angle)
{
	bool found = false;
	semaphoreInitialize(sweepingForObjectSemaphore);

	startTask(findClosestTargetDuringScan);
	while (!found)
	{
		float thetaInDegrees = myRadiansToDegrees(gCurrentPose.theta);

		semaphoreLock(sweepingForObjectSemaphore);
		writeDebugStreamLine("Main: scanning for object");
		rotateRobotToHeadingInDeg(thetaInDegrees - halfSweepAngle, fineRotatePower);
		rotateRobotToHeadingInDeg(thetaInDegrees + halfSweepAngle, fineRotatePower);
		//rotateRobotToHeadingInDeg(thetaInDegrees, fineRotatePower);
		//writeDebugStreamLine("Main: done scanning, unlocking semaphore");
		semaphoreUnlock(sweepingForObjectSemaphore);
		//writeDebugStreamLine("Main: waiting for monitor task");
		semaphoreLock(findObjectResultSemaphore);
		writeDebugStreamLine("Main: result ready, object distance is %d, angle is %d degrees",
				gTargetDistance * 10, myRadiansToDegrees(gTargetAngle));
		semaphoreUnlock(findObjectResultSemaphore);
		if (gTargetDistance < 255)
		{
			found = true;
		}
		else
		{
			break;
		}
		wait1Msec(50);
	};
	stopTask(findClosestTargetDuringScan);
	distance = gTargetDistance * 10;
	angle = myRadiansToDegrees(gTargetAngle);
	return found;
}

bool captureTarget(float distanceToTarget, float angleToTarget)
{
	rotateRobotToHeadingInDeg(angleToTarget, rotatePower);
	wait1Msec(50);
	int ticks = distanceToTicks(distanceToTarget);

	// Drive robot in straight line to destination
//	nSyncedMotors = synchMode; // sync motors Right as master and Left as slave
//	nSyncedTurnRatio = 100; // motors move at 100% alignment to each other

	nMotorEncoderTarget[Right] = ticks;	nMotorEncoderTarget[Left] = ticks;
	motor[Right] = maxPower;	motor[Left] = maxPower;

	while (nMotorRunState[Right] != runStateIdle || nMotorRunState[Left] != runStateIdle) //while Right and Left motors are not in idle
	{
		// if we are < MaxCaptureDistance cm have run into object
		if (SensorValue[Distance] < MaxCaptureDistance)
		{
			writeDebugStreamLine("capture distance achieved");
			break;
		}
	}
	motor[Right] = 0;
	motor[Left] = 0;
//	nSyncedMotors = synchNone;
	return (SensorValue[Distance] < MaxCaptureDistance);
}

task stopAfterBlackLine()
{
	while (1)
	{
		if (SensorValue[Light] < LightSensor_FloorTile_BlackTape_Threshhold)
		{
			while (1)
			{
				if (SensorValue[Light] > LightSensor_FloorTile_BlackTape_Threshhold)
				{
					writeDebugStreamLine("Black line passed.");
					// stop robot
					gStopGoingToDest = true;
					motor[Right] = 0; motor[Left] = 0;
					return;
				}
				wait1Msec(50);
			}
		}
		wait1Msec(50);
	}
}

void turnTorwardCenterOfRoom()
{
	writeDebugStreamLine("Turning toward center of room.");
	Vector2d toRoomCenter;
	Pose pose;
	semaphoreLock(currentPose);
	assignPose(pose, gCurrentPose);
	semaphoreUnlock(currentPose);
	// calculate vector to destination in robots POV
	calculateVectorToDest(pose, roomCenter, toRoomCenter);
	float angleToTurn = calculateTurnAngleToDest(toRoomCenter);
	writeDebugStreamLine("angle = %d", myRadiansToDegrees(angleToTurn));
	rotateRobot(angleToTurn);
}

bool gTurnTowardCenterIfBlackLineHitActing = false;
task turnTowardCenterIfBlackLineHit()
{
	while (1)
	{
		if (SensorValue[Light] < LightSensor_FloorTile_BlackTape_Threshhold)
		{
			gTurnTowardCenterIfBlackLineHitActing = true;
			writeDebugStreamLine("Black line detected.");
			// stop robot
			motor[Right] = 0; motor[Left] = 0;
			wait1Msec(50);
			turnTorwardCenterOfRoom();
			wait1Msec(50);
			driveRobotStraightInMm(200);
			wait1Msec(50);
			gTurnTowardCenterIfBlackLineHitActing = false;
			return;
		}
		wait1Msec(50);
	}
}


void playColorSound();

task main()
{
	int canCount = 0;
	clearDebugStream();
	nVolume = SoundVolume;
  bFloatDuringInactiveMotorPWM = false;
  nPidUpdateInterval    = 10;   // Best performance if we do really frequent updates
                                // (i.e. calculation) on the motor speeds to correct
                                // for errors.

	// start robot in center of the trash can area facing down the edge of the "room" toward the far side
	setPose(gCurrentPose, home[0], home[1], 0.0);

	// start the localization task
	startTask(localize);

	//int angle = -90;
	//wait1Msec(1000);
	//while(1)
	//{
	//	goToDestination(1000,0);
	//	wait1Msec(50);
	//	goToDestination(1000,-1000);
	//	wait1Msec(50);
	//	goToDestination(0,-1000);
	//	wait1Msec(50);
	//	goToDestination(0,0);
	//	rotateRobotInDeg(angle);
	//  waitUntil(nNxtButtonPressed != kNoButton);
	//	wait1Msec(1000);
	//}

	//goToDestination(home[0]+500, home[1]);
	//wait1Msec(50);
	//goToDestination(home[0] +500, home[1]+500);
	//wait1Msec(50);
	//goToDestination(home[0], home[1] + 500);
	//wait1Msec(50);
	//goToDestination(home);
	//wait1Msec(50);
	//rotateRobotToHeadingInDeg(0);

	//waitUntil(0);
	//rotateRobotToHeadingInDeg(45, rotatePower);
	//gotoDestination(roomCenter);
	//waitUntil(nNxtButtonPressed == kEnterButton);
	//goToDestination(home);
	//rotateRobotToHeadingInDeg(0, rotatePower);

	//waitUntil(0);
	bool nearOrAtHome = true;
	float distToClosestTarget, angleToClosestTarget;

	driveRobotStraightInMm(250); // get out of white area
	while (1)
	{
		//displayCenteredTextLine(1, "Floor Light Sensor");
		//displayCenteredTextLine(2, "%d", SensorValue[Light]);
		//displayColorSimple();
		//goToDestination(1000,1000);
		//driveRobotStraightInMm(-100);
		//gotoDestination(home);

		// If at home turn robot to face center of "room"
		if (nearOrAtHome)
		{
		  turnTorwardCenterOfRoom();
			//rotateRobotToHeadingInDeg(HeadingToPointBeforeSearch, rotatePower);
		}
		wait1Msec(50);
		nearOrAtHome = false;
		if (findClosestTarget(distToClosestTarget, angleToClosestTarget))
		{
			wait1Msec(50);
			if (distToClosestTarget < DistCloseEnoughForNoCorrection)
			{
				writeDebugStreamLine("distance to target is %d, attempting to capture it", distToClosestTarget);
				bool captured = captureTarget(distToClosestTarget + captureSlopDistance, angleToClosestTarget);
				if (captured)
				{
					writeDebugStreamLine("Object captured!");
					wait1Msec(50);
					// detect color of object and play sound
					// rotate so object is in front of color sensor
					rotateRobotInDeg(AngleToRotateToSenseCanColor, fineRotatePower);
					playColorSound();
					waitUntil(bSoundActive == false);
					writeDebugStreamLine("Bringing object home");
					startTask(stopAfterBlackLine);
					gStopGoingToDest = false;
					goToDestination(home);
					stopTask(stopAfterBlackLine);
					semaphoreLock(currentPose);
					writeDebugStreamLine("at home location = %d, %d", gCurrentPose.pos[0], gCurrentPose.pos[1]);
					writeDebugStreamLine("error = %d, %d", gCurrentPose.pos[0] - home[0], gCurrentPose.pos[1] - home[1]);
					semaphoreUnlock(currentPose);
					wait1Msec(50);
					driveRobotStraightInMm(BackupDistanceAfterDropOff);
					rotateRobotInDeg(-180);
					nearOrAtHome = true;
					canCount++;
					//waitUntil(nNxtButtonPressed == kEnterButton);
				}
				else
				{
					writeDebugStreamLine("Object missed!");
					playSoundFile("Woops.rso");
					// backup a little and try again
					driveRobotStraightInMm(-200);
				}
			}
			else // distToClosestTarget >= DistCloseEnoughForNoCorrection
			{
				writeDebugStreamLine("distance to target is %d > threshold, driving to it and scanning again.", distToClosestTarget);
				rotateRobotToHeadingInDeg(angleToClosestTarget, rotatePower);
				// TBD think about whether to just go DistCloseEnoughForNoCorrection here before another sweep
				startTask(turnTowardCenterIfBlackLineHit);
				driveRobotStraightInMm(distToClosestTarget / 2.0);
			  waitUntil(gTurnTowardCenterIfBlackLineHitActing == false);
				stopTask(turnTowardCenterIfBlackLineHit);
			}
		}
		else // found no target so go forward some toward center of room
		{
			writeDebugStreamLine("Found no target so going toward center of room");
			turnTorwardCenterOfRoom();
			//rotateRobotToHeadingInDeg(HeadingToPointBeforeSearch, rotatePower);
			driveRobotStraightInMm(DistCloseEnoughForNoCorrection);
		}

		if (canCount == NumberOfCansToCollect)
		{
			playSound(soundUpwardTones);
			waitUntil(bSoundActive == false);
			waitUntil(0);
			stopAllTasks();
			return;
		}
  	wait1Msec(50);       // The program waits n milliseconds before running further code
	}
}

void playColorSound()
{
	// Check the detected colour and display the name of the
  // color in a large font on the screen.
  switch(SensorValue[Color])
  {
//    case BLACKCOLOR:  displayCenteredTextLine(6, "Black");   break;
  	case BLUECOLOR:   playSoundFile("BlueCan.rso");    break;
//    case GREENCOLOR:  displayCenteredTextLine(6, "Green");   break;
//    case YELLOWCOLOR: displayCenteredTextLine(6, "Yellow");  break;
    case REDCOLOR:    playSoundFile("RedCan.rso");     break;
    case WHITECOLOR:  playSoundFile("WhiteCan.rso");   break;
    default:          playSoundFile("Woops.rso"); break;
  }
}
