#pragma config(Motor,  motorA,          Pen,           tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          Left,          tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          Right,         tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("debugStream")
#pragma DebuggerWindows("nxtLCDScreen")

typedef enum Part { partBody, partPen } Part;

#include "vector.c"
#include "constants.c"
#include "trig.c"
#include "wheelTicks.c"
#include "pose.c"
#include "globals.c"
#include "localize.c"
#include "navigation.c"
#include "movementCommands.c"
#include "target.c"
#include "sound.c"


void penDown()
{
	if (!gPenEnabled)
		return;

	if (gPenState == UP)
	{
		nMotorEncoder[Pen] = 0;
		motor[Pen] = 10;
		waitUntil(nMotorEncoder[Pen] >= penUpDownTicks)
		motor[Pen] = 0;
		gPenState = DOWN;
	}
}

void penUp()
{
	if (!gPenEnabled)
		return;

	if (gPenState == DOWN)
	{
		nMotorEncoder[Pen] = 0;
		motor[Pen] = -10;
		waitUntil(nMotorEncoder[Pen] <= -penUpDownTicks)
		motor[Pen] = 0;
		gPenState = UP;
	}
}

const Vector2d points[] = {
													 {93.0, 0.0},
													 {67.0 + left_bias_offset, 127.0}
													};

void printPenLoc()
{
	writeDebugStreamLine("Pen loc = (%f, %f)",
		gCurrentPose.pos[0] + robotPenDistanceInX * cos(gCurrentPose.theta),
		gCurrentPose.pos[1] + robotPenDistanceInX * sin(gCurrentPose.theta);
}

task main()
{

  // Firmware has been instrumented to trace the motor speed/PID regulation on a single motor. The output is
  // sent to the Debugger's "Debug Stream" window. By default, the trace messages are disabled. You should
  // be continuously connected  (via USB or Bluetooth) to the NXT to get the full trace output; otherwise the
  // internal buffers can overflow and some trace records can be lost.
  //
  // The statement below initializes the trace on 'motorA'.
  //
  //nMotorBeingTrace = motorB;

  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
  //
  // Firmware has been enhanced to smoothly ramp up the speed regulation on a motor. And it will smoothly ramp
  // down the speed when using firmware to move to a target encoder position. The ramping parameters are configured
  // on a per motor basis with the folowing intrinsic function call.
  //
  // There are two parameters for ramping up and ramping down:
  //   1. The rate at which the speed is adjusted. An adjustment is made every 25 milliseconds.
  //   2. The initial starting speed to use when starting from stopped condition. This avoids the "dead band" that
  //      occurs at very low raw power levels where the motor is not moving. Note that a value of zero is a flag to
  //      indicate that speed ramping is not used. For "ramp down" the minimum speed is used to indicate the lowest
  //      speed that the motor should achieve.
  //
  // By default, these parameters are all zero indicating that speed ramping is disabled.
  //
  // NOTE: When moving to a target encoder position the firmware already had a PID based algorithm to move the
  //       motor to a smooth stop at the target encoder position. This algorithm "kicks in" when there are about
  //       50 to 100 encoder ticks left before reaching the target encoder position; the exact distance at which
  //       it kicks in is based on the current speed setting of the motor -- it is a longer distance for higher
  //       speeds. The "ramp down" function for this function is applied before this PID algorithm takes effect.
  //

	nMaxRegulatedSpeedNxt = 1000;
	clearDebugStream();
	nVolume = SoundVolume;
  bFloatDuringInactiveMotorPWM = false;
  nPidUpdateInterval    = 10;   // Best performance if we do really frequent updates
                                // (i.e. calculation) on the motor speeds to correct for errors.

	// start robot on first point facing toward second point along x axis
	setPose(gCurrentPose, home[0], home[1], 0.0);

	// start the localization task
	startTask(localize);
	wait1Msec(100);

	gPenEnabled = true;

	// Testing forward 12 inches, backwards 12 inches
	//driveRobotStraightInMm(12*25.4);
	//wait1Msec(3000);
	//driveRobotStraightInMm(-12*25.4);
	//wait1Msec(3000);

	// testing rotate CCW 180 deg, then CW 180 deg
	//rotateRobotInDeg(180);
	//printPose(gCurrentPose);
	//wait1Msec(5000);
	//rotateRobotInDeg(-180);
	//printPose(gCurrentPose);

	// Testing rotation
	//calibrateRotate(-180);
	//printPose(gCurrentPose);

	// Testing straight run
	//calibrateStraightRun();
	//printPose(gCurrentPose);

	// test pen up / pen down
	//penDown();
	//wait1Msec(5000);
	//driveRobotStraightInMm(50);
	//wait1Msec(5000);
	//penUp();


	//stopAllTasks();
	//return;

	// play start tone
	playSound(soundFastUpwardTones);
	waitUntil(bSoundActive == false);

	int pointIndex = 0;

	writeDebugStreamLine("robot start pos");
	printPose(gCurrentPose);
	writeDebugStreamLine("pen start pos");
	printPenLoc();

	// draw pen along direction of bot to first point
	goToDestination(points[pointIndex][0],points[pointIndex][1], partPen);

	writeDebugStreamLine("after draw to first point robot pos");
	printPose(gCurrentPose);
	printPenLoc();

	wait1Msec(100);

	penUp();

	// TBD while points loop
	{
		// move bot to current point
		goToDestination(points[pointIndex][0],points[pointIndex][1], partBody);
		writeDebugStreamLine("after bot to current point robot pos");
		printPose(gCurrentPose);
		wait1Msec(100);

		pointIndex++;

		// Turn toward next point
		turnToDestination(points[pointIndex][0],points[pointIndex][1], partBody);
		wait1Msec(100);
		writeDebugStreamLine("after turning to next point robot pos");
		printPose(gCurrentPose);
		//writeDebugStreamLine("mm to next pen on point = %f", ticksToDest / ticksPerMm);

		// back up robot so pen is on current point again.
		driveRobotStraightInMm(-robotPenDistanceInX);

		penDown();
		writeDebugStreamLine("after backing up robot pos");
		printPose(gCurrentPose);
		printPenLoc();
		wait1Msec(100);

		// draw pen to next point
		goToDestination(points[pointIndex][0],points[pointIndex][1], partPen);
		writeDebugStreamLine("after drawing to next point robot pos");
		printPose(gCurrentPose);
		printPenLoc();

		wait1Msec(100);

		//penUp();
	}
	// TBD end of while loop

	playSound(soundUpwardTones);
	stopAllTasks();
}
